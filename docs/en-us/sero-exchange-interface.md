#  SERO Exchange Interface (SEI) Interface Description

[MENU]

The connection method of the SEI interface, the exchange service hosts the user's TK, is responsible for tracking the user's UTXO, and provides online and offline signature methods.
Compared with the SSI interface, which requires the peer to manage UTXO itself, SEI is simpler, safer, and more practical.

**[gero v0.7.2-beta.7.2](?file=News/Release/SERO-BETANET-R7.2) and above only provides SEI Interface


## Please note the users and read this article carefully.

1. **Seed-> SK-> TK-> PK has a one-to-one correlation, a PK can correlate to a very large number of PKr through random numbers.**

2. **Each user is associated with a different PKr through a random number, and then associated with a unique PK. There is no need to generate a seed for each user.**

3. **Please frequently merge the UTXO of the account, otherwise too much UTXO during the transfer will cause the signature time to be too long, which will seriously affect the user experience.**

## Account

Account by $Seed$, $SK$, $TK$, $PK$, $PKr$ is composed of four keys, and the generation relationship is as follows:

```
seed(seed) -> sk(Private Key) -> TK(Tracking Key) -> PK(Public Key) -> PKr(Receipt Code)
```

There are currently two account generation libraries in **Go** and **JS** :

**Go** language version:
<https://github.com/sero-cash/go-czero-import/keys/keys.go>

**JS** language version:
* <https://github.com/sero-cash/js-sero-client>
* Example: https://github.com/sero-cash/js-sero-client/blob/master/src/test/test_account.js
* Install npm module

```bash
npm install js-sero-client
```

### seed

* $seed$ is a 32-byte BYTE array, which can be generated by HASH algorithm or mnemonic. Having $seed$ can release all subsequent keys, so it must be kept absolutely secure.

### sk (Private Key)

* The Private key $SK$ has a total of 64 BYTE, consisting of two large integers of 32 BYTE, and correlates one-to-one with $seed$ 
  * $sk=(zsk,vsk) \;\;zsk \in Fr, \; vsk \in Fr $  
* The private key is used to sign the transaction and also needs to be kept absolutely secure.
* Can be generated as $seed$

* **Go Language**

```go
  cpt.ZeroInit_OnlyInOuts()    // Initialize the encryption library
  var seed keys.Uint256
  seed=c_type.RandUint256()
  sk:=superzk.Seed2Sk(
    &seed,                    // Seed 32 Byte Random Number
    1                         //SuperZK Protocol version 1: SuperZK1.0, 2: SuperZK2.0   
  )
```

* **JS language**

```js
const newKeysBySeed = require('js-sero-client').newKeysBySeed
let seed = Buffer.alloc(
      32,
      'fd1b401d2bbfa09fba577b398b09b5ea075bd8f37773095c6e62271a4b080977',
      'hex'
)
let keys = newKeysBySeed(
  seed,                 //seed Can be used directly as a string (hex|base58)
  1                     //SuperZK Protocol version 1: SuperZK1.0, 2: SuperZK2.0
)
let sk = keys.sk.toString('hex')
let tk_hex = keys.tk.toString('hex')
let tk_base58 = keys.tk.ToBase58()
```

### TK (Tracking Key)

* $TK$ is a 64-length BYTE array consisting of a 32 BYTE $ECC_{fp}$ points and a large integer. The  $ZPK$ is the first 32 BYTE of $PK$, $vsk$ is the last 32 BYTE of $sk$. One-to-one correlation between $TK$ and $sk$.
  * $TK=(ZPK,vsk) \; ZPK \in ECC_{fp},\; vsk \in Fr$
* $TK$ can only be used to view the details of UTXO belonging to the account and can be provided to trusted third parties for independent auditing.
* $TK$ is generated by $sk$

* **Go language**

```go
  tk:=superzk.Sk2Tk(&sk)   //SuperZK1.0/2.0 Can be used
```

* **JS language**

```js
  const newKeysBySk = require('js-sero-client').newKeysBySk
  let sk = Buffer.alloc(
         64,
         '4e7f432c24d2......e1513eadfef9d1cd604',
         'hex'
  )
  let keys = newKeysBySk(sk)   //sk Can be used directly as a string (hex|base58)
  let tk_hex = keys.tk.toString('hex')
  let tk_base58 = keys.tk.ToBase58()
  let pk_hex = keys.pk.toString('hex')
  let pk_base58 = keys.pk.ToBase58()
```

#### PK (Public Key)

* Public key $PK$ is also 64 BYTE, which consists of two 32 BYTE $ECC_{fp}$, points, correlates one-to-one with $TK$
  * $PK=(ZPK,VPK)  \; ZPK \in ECC_{fp}, \; VPK \in ECC_{fp}$
* $PK$ is used to generate $PKr$ (Receipt Code). You can provide $PK$ to a third party. $PK$ generates yours $PKr$ (Receipt Code), will then be used to transfer you money and use $TK$ to track the account. However, because of the relationship between safety and performance, it is not recommended to use it directly.

* $PK$ is generated by $TK$ 

* **Go language**

```go
 pk:=superzk.Tk2Pk(&tk)        // tk: SuperZK1.0/2.0 Protocol tracking keys
```

* **JS language**

```js
  const newKeysByTk = require('js-sero-client').newKeysByPK
  let tk = Buffer.alloc(
         64,
         '6a367411b800be76a9d......1ee1513eadfef9d1cd604',
        'hex'
  )
  let keys = newKeysByTk(tk)      //tk Can be used directly as a string (hex|base58)
  let pk_hex = keys.pk.toString('hex')
  let pk_base58 = keys.pk.ToBase58()
```

#### PKr (Receipt Code)

* Payment code $PKr$ is a binary data of 96 BYTE, composed of three 32 BYTE $ECC_{fp}$. You can convert $PK$ and a random number to $PKr$ through `keys.Addr2PKr`
  * $PKr=(ZPKr,VPKr,BASEr) \; ZPKr \in ECC_{fp}, \; VPKr \in ECC_{fp}, \; BASEr \in ECC_{fp}$
* $PKr$ is the target of UTXO. Each $PK$ corresponds to a very large number of $PKr$. The UTXO pointing to this $PKr$ can be decrypted by $TK$ and signed by $sk$ when in use.
* $PKr$ is generated by adding a 32 BYTE random number to $PK$.

* **Go language**

```go
  rnd:=c_superzk.RandomFr()  
  pkr:=superzk.PK2PKr(&pk,&rnd)    //SuperZK2.0/1.0 Can be used
```

* **JS language**

```js
  const newKeysByPK = require('js-sero-client').newKeysByPK  //SuperZK1.0/2.0 shared
  const Czero = require('js-sero-client').Czero
  let pk = Buffer.alloc(
         64,
         '6a367411b800be......df5fb72aba4019',
         'hex'
  )
  let rnd = Czero.RandomU32()
  let keys = newKeysByPK(pk)    //pk Can be used directly as a string (hex|base58)
  let pkr = keys.GenPKr(rnd)
  let pkr_hex = pkr.toString("hex")
  let pkr_base58 = pkr.ToBase58()
```

#### Interchange between Base58 and Hex encoding in gero console

```javascript
> web3.addressToHex(sero.accounts[0])
"0x0dbd9c096......849304201ea6"

> web3.hexToBase58("0x0dbd9c09......9304201ea6")
"GwA94QDTyQ86cE5jcuYCyrQ9Bu9FRcXfq4dxQhryTDzhkahUjYSHcjZ5yFF9bvaZPRMUwR8k5uW4bT3DvPf77a5"
```

## Offline Signature

After configuring the transaction in a full node program (gero), you need to use sero's client for offline signing.

Offline signing program is also divided into Go version and JS version.

#### Go Language
* Example program: https://github.com/sero-cash/go-sero/blob/v0.7.2-dev/cmd/tx/main.go

  ```go
  import 'github.com/sero-cash/go-sero/zero/txtool/flight'
  import 'github.com/sero-cash/go-sero/zero/txtool'
  import 'github.com/sero-cash/go-czero-import/cpt'
  param_str:='{"Gas":25000,"GasPrice":1000000000,"From":{"SKr":"0x0 .... }'  // Configured from full nodes sk_str:='0xfd1b401d2bbfa09fba577b398b09b5ea075bd8f37773095c6e62271a4b080977'
  //------ initialization -----
  cpt.ZeroInit_OnlyInOuts() // Can only be executed once globally
  //------txParam---
  var param txtool.GTxParam
  json.Unmarshal([]byte(param_str),&param)
  //------Private key ----
  bs, _ := hexutil.Decode(sk_str)
  sk := keys.Uint512{}
  copy(sk[:], bs)
  //------ Signature ----
  gtx, _:=flight.SignTx(sk,param)
  //------ Convert to JSON -----
  tx, _ := json.Marshal(&gtx)
  ```
#### JS Language
* Sample program: https://github.com/sero-cash/js-sero-client/blob/master/src/test/test_tx.js

  ```javascript
  const account = require('js-sero-client').Account
  const tx = require('js-sero-client').Tx
  //------
  const seedStr = 'fd1b401d2bbfa09fba577b398b09b5ea075bd8f37773095c6e62271a4b080977'
  const txParamStr = '{"Gas":25000,"GasPrice":1000000000,"Fro .... }'       // Configured from full nodes
  //------
  const seed = Buffer.alloc(32, seedStr, 'hex')
  const keys = account.NewKeys(seed)
  const skStr = keys.sk.toString('hex')
  //------
  tx.SignTx(
    txParamStr,
    skStr,                        // String hex|base58
    (err, tx) => {
      if (err) {
        console.error(err)
      } else {
      console.log(tx)
      }
    }
  )
  ```

#### Note
  * The signature program determines the number of parallel calculations based on the performance of the current machine, and the transaction generation time is proportional to the number of UTXOs referenced.
    * If you spend a lot of UTXO, the generation time will become very long.
  * Solution
    * For online signature applications, merge the incoming UTXO.
      * gero's exchange service provides automatic merge function, add `—autoMerge` to gero to automatically merge UTXO.
    * You can extend the timeout of interface calls.
      * `--rpcwritetimeout [SECOND]` Add this parameter when starting gero to set the timeout for gero writeback, in seconds.
    * For offline signing applications
      * Run multiple signatures in parallel
      * Use genMergeTx to generate offline signature transaction parameters, and then send them after offline signature.

## Import Account
gero has two ways of importing accounts, namely $seed$ and $TK$. After importing $TK$, gero can only be used to track the account balance and recharge records or generate receipt codes. The transactions generated must be submitted to the chain after being signed offline. Importing $seed$ can directly use gero to sign transactions.

* Import $seed$

  * Import with mnemonic words $seed$ in $web3$:

  ```javascript
  > personal.importMnemonic("uncle frost ex.....ion before","123456")  // Mnemonic, password
  "GwA94QDTyQ86cE5jcu......aZPRMUwR8k5uW4bT3DvPf77a5"    // Public key PK
  ```

  * The mnemonic corresponding to the derived seed is

  ```javascript
  > personal.exportMnemonic(sero.accounts[0],"123456")  // Public key PK, password
  "uncle frost expose ...... salmon champion before"
  ```

  * Directly import hex-encoded $seed$ (32 bytes random number)

  ```javascript
  > personal.importRawKey(
    "ec8bad429641f......0b1ab03d1f", //Seed
    "123456",                        //password
    1,                               // protocol version 1: SuperZK1.0，2: SuperZK2.0
    1800000                          // Account balance analysis from 1.8 million blocks
  )
  "GwA94QDTyQ86cE5jc......8k5uW4bT3DvPf77a5"     // Public key PK
  ```

  * Export hex-encoded $seed$, need to have this account imported already.

  ```javascript
  >personal.exportRawKey("GwA94QDTyQ86cE5j....DvPf77a5","123456")  // Public key PK, password
  ```

  * Then use accounts to view the public key of the imported account

  ```javascript
  > sero.accounts
  ["GwA94QDTyQ86cE5jcuYCyrQ9Bu9FRcXfq4dxQhryTDzhkahUjYSHcjZ5yFF9bvaZPRMUwR8k5uW4bT3DvPf77a5"]
  ```

  * Import $TK$, can only view and track transactions and balances, cannot send transactions.

  ```javascript
  > personal.importTk(
    "GwA94QDTyQ86cE5......AwUB22sEmQQ1AguYXn", //TK
    1800000                                    // Account analysis from 1.8 million blocks
  )
  "GwA94QDTyQ86cE5jcuYCyr......bvaZPRMUwR8k5uW4bT3DvPf77a5"   //公钥PK
  ```

  * View of account $TK$
  ```javascript
  > sero.getTk(sero.accounts[0])                        // Public key PK
  "GwA94QDTyQ86cE5jcuYCy.......AwUB22sEmQQ1AguYXn"      //TK
  ```

  * After importing the account, the exchange service will automatically analyze the block information. If it is a newly imported account, the service will take some time to analyze the latest block. You can see if the analysis is complete by looking at gero's logs.
  * You need to open the `—exchange` mark

  ```
  INFO [06-13|15:44:00.016] Exchange indexed                         blockNumber=1031753
  INFO [06-13|15:44:50.007] Exchange indexed                         blockNumber=1031754
  INFO [06-13|15:45:00.007] Exchange indexed                         blockNumber=1031755
  INFO [06-13|15:45:10.007] Exchange indexed                         blockNumber=1031756
  ```

  Regardless of whether $seed$ or $TK$ is imported, `gero` will generate a keystore for it, where $seed$ is stored in the form of secret text, $TK$ is stored in clear text.

* **After importing the account, the exchange analysis will start from block 1. In order to avoid too long exchange analysis time, users can:**

  * By modifying the number of automatically skipped blocks in the keystore file

  ```javascript
  {
    "address":"24DidZ7...KWTQtU8",
    "tk":"24Did...BaG84r",
    "crypto":{
          "cipher":"aes-128-ctr",
          "ciphertext":"4e4b3247...adbff2",
          "cipherparams":{"iv":"1d13d245...3f9db2"},
          "kdf":"scrypt",
          "kdfparams":{"dklen":32,"n":262144,"p":1,"r":8,"salt":"e17991a97...b1b7bd"},
          "mac":"b66f0c...2dd7d06"
    },
    "id":"f939...28c",
    "version":1,
    "at":1050000                  // Increase at automatically, skip the previous 1 ~ 1050000 blocks automatically
  }
  ```

  * Or provide the at parameter when importing the account.

## Rpc version of the offline interface `v0.7.9`

Currently, the offline API interface provides two languages, go and javascript. Other languages ​​can use these functions by starting a gero that is not connected to the outside world through rpc.

* **seed generates sk**

  ```javascript
  exchange.seed2Sk(
    "0xec8bad429......0b1ab03d1f",
    1                                  //SuperZK Protocol version 1：1.0 2：2.0
  )    //seed: hex encoding
  "0x8fe1c73ac......0d1bc4305"                       //sk: hex encoding
  ```

* **sk generates TK**

  ```javascript
  exchange.sk2Tk("0x8fe1c7......40d1bc4305")    //sk: hex encoding
  "GwA94QDTy......QQ1AguYXn"                    //TK: base58 encoding
  ```

* **TK generates PK**

  ```javascript
  exchange.tk2Pk(
    "GwA94QDTyQ86c......1AguYXn",   //TK: hex or base58 encoding
  )
  "GwA94QDTyQ8......uW4bT3DvPf77a5"              //PK: base58 encoding
  ```

* **PK generates PKr**

  ```javascript
  >  exchange.pk2Pkr(
    "GwA94QDTyQ8......uW4bT3DvPf77a5",            //PK
    "0x000000000......0000110"                    //32 byte The random number is automatically generated if it is empty
  )  // PK,RNG
  "22mZ61am......aevRpWMD89"           //PKr: base58 encoding
  ```

* **Offline signature**

  ```javascript
  > const sk = '0xfd1b401d2bbf......71a4b080977'                            // Private key SK: hex encoding
  > const txParamObj = {"Gas":25000,"GasPrice":1000000000,.... }       // Configured by a full node (not a string)
  > var tx=exchange.signTxWithSk(txParamObj,sk)
  ```

## Wallet interface

SERO's full node program (gero) provides a set of services specifically for exchange listing. Exchange makes third-party listing easier. The listing party can obtain the account-related balance and record information on the chain when only the $TK$ of the account is imported. The interface supports both `jsonrpc` and `console`.

#### Start the exchange service of the full node (gero)
* You can learn about the full node program (gero) in the following places
  * Code location
    * <https://github.com/sero-cash/go-sero>
  * How to compile the source code
    * <https://wiki.sero.cash/zh/index.html?file=Start/from-the-sourcecode-base-on-centos7>

* Binary Program Release Location
  * <https://github.com/sero-cash/go-sero/releases>

* How to run a binary program
* <https://wiki.sero.cash/zh/index.html?file=Start/from-the-binary-package>

* Add the startup gero `—exchange` and `--rpcapi exchange,sero` two parameters to open gero of exchange services.
  * `–exchange` Start `exchange` service
  * `--rpcapi sero,exchange` Open the jsonrpc interface of `exchange` and `sero`
  * Other `rpc` parameters are consistent with Ethereum

* In order to ensure security when the computing power fluctuates greatly, the number of confirmed blocks can be set.
  * `--confirmedBlock 32` Set 32 ​​blocks to confirm the transaction. The default is 12 blocks.

* The rpc of SERO has a limit on the request size, and the default is 512K.

  * `--rpcRequestContentLength 1048576` Can change the limit to 1M

* If you cannot handle the bigint type when the jsonrpc return value is serialized, you can make jsonrpc return a numeric value as a string.

  * `--exchangeValueStr` Will make gero's jsonrpc interface return the value as a string.

* In order to store data on the hard disk as little as possible, gero currently saves snapshots every 10,000 blocks or 1 hour, so when gero is closed, synchronization will start from the nearest integer multiple of 10,000.

  * `--gcmode archive` Will make gero save snapshot data for each block, and will not roll back the block when restarting. But this method will consume more hard disk storage.

* When gero has a large number of UTXO signatures, it will take more time to sign, so you can adjust the timeout for gero to write back to the client.

  * `--rpcwritetimeout [SECOND]` Add this parameter when starting gero to set the timeout for gero writeback, in seconds.

* Example startup parameters

  ```sh
./gero --exchange --datadir ~/geroData --port 53717 --rpc --rpcport 8545 --rpcapi exchange,sero,net --rpcaddr 127.0.0.1  --rpccorsdomain "*" --keystore ~/keystore --confirmedBlock 32 --rpcwritetimeout 1800 --exchangeValueStr
  ```

  * The listing party can modify the above configuration according to requirements

#### Interface Introduction

* **`exchange` Interface provided by SERO**

  * [`GetBlockByNumber(num)->block`](#GetBLockByNumber) `v7.5`
  * Get basic information of a block
  * You can also use `sero.GetBlockByNumer` to get more detailed information, the usage is compatible with Ethereum
  * [`GetBlocksInfo(start,end)->blocks`](#GetBlocksInfo)`v7.5`
    * Get `start~end` details between blocks
  * [`GetPkr(pk,rnd)->pkr`](#GetPKr)
    * Generate payment code $pkr$ based on public key $pk$ and random number $rnd$
  * [`GetPkByPkr(pkr)->pk`](#GetPkByPkr)`v7.5`GetPkByPkr(pkr)->pkv7.5
    - Reverse check `pk` by payment code `pkr`
    - `Pk` The corresponding account must be in `gero` 
  * [`GetBalances(pk)->balances`](#GetBalances)
    * Get the total $balance$ by public key $pk$
  * [`GetRecords(begin,end,[pk])->[]Utxo`](#GetRecords) `v7.5`
    * Get the $UTXO$ that the account `pk` has recharged between the block number $begin$ and $end$.
  * [`GenTx(preTxParam)->txParam`](#GenTx)
    * Get the `txParam` that can be used for signature through `preTxParam`.
  * [`GenMergeTx(mergeParam)->txParam`](#GenMergeTx) `v7.5`
    - Generate merged transaction parameters `txParam` based on the parameter `mergeParam`. `txParam` requires offline signature.
  * [`GetTx(txhash)->tx`](#GetTx) `v7.5`
    * Get details of transaction hash
    * Currently only provide accounting records
  * [`GenTxWithSign(preTxParam)->tx`](#GenTxWithSign)
    * Generate pre-signed tx directly through `preTxParam`
    * Account needs to be imported `seed`
  * [`CommitTx(tx)->()`](#CommitTx)
    * Submit the signed tx to the transaction pool and broadcast it to the entire network
  * [`GetPkSynced(pk)->pkState`](#GetPkSynced)
    * Get the analysis of current `exchange` account 
  * [`Merge(pk,currency)->txhash`](#Merge)
    * Online signature
    * Automatically merge $UTXO$ of `currency` 
    * The target value is less than 10 UTXO
  * [`ValidAddress(pk|pkr)->bool`](#ValidAddress)
    * Check if PK or PKr is legal
  * [`GetLockedBalances(pk)->lockedState`](#GetLockedBalances) ` > v7.3`
    * Check the amount of locks that may result from generating transactions
  * [`GetMaxAvailable(pk,currency)->value`](#GetMaxAvailable) `> v7.3`
    * Get the maximum amount that the currency currency can currently send
  * [`ClearUsedFlag(pk)->()`](#ClearUsedFlag) `> v7.3`
    * Clear UTXO flag locked under PK due to sending transaction
  * [`ClearUsedFlagForRoot([root,...])->()`](#ClearUsedFlagForRoot) `> v7.4`
    - Clear the lock token of UTXO represented by root

###GetBlockByNumber
- Get the current block information according to the block number
- **jsonrpc**
  - request
  ```javascript
  {
      "id": 0,
      "jsonrpc": "2.0",
      "method": "exchange_getBlockByNumber",
      "params": [
      109                  // Block number, empty means to get the latest block。
        ]
  }
  ```

  - response
  ```javascript
  {
      "id": 0,
      "result": {
      "BlockHash":"0x61de8473709....3172c2225e55"， // Block hash
      "BlockNumber": 109,                           // Block number
      "ParentHash": "0xaf5f6bf0814203a8b49fc3398489e029dd4e9e5da45be241d3f85fc234f341aa"
      "timestamp": 1561398077                  // Timestamp
      "TxHashes": [                            // Transaction hash list
        "0xc31c834efe568d56e7b4c60e7aefe2b223e8567244f242c7870ec5cb47cc1000", 
        "0x9123159d7016086ed4e1ec253f575cd38f04cc4dea31ce922d1387c985e336c8"
      ]
    }
        "error": null
  }
  ```

- **console**

```javascript
>  exchange.getBlockByNumber(109)
{
    "hash":"0x61de8473709567be5278c2e607915e6f9001f45f51dc94f8792a3172c2225e55"，
    "number": 109, 
    "timestamp": 1561398077,
    "TxHashes": [
      "0xc31c834efe568d56e7b4c60e7aefe2b223e8567244f242c7870ec5cb47cc1000", 
      "0x9123159d7016086ed4e1ec253f575cd38f04cc4dea31ce922d1387c985e336c8"
    ]
}
```

### GetBlocksInfo
- Get UTXO usage information for a range of blocks
- **jsonrpc**
  - request
  ```javascript
  {
      "id": 0,
      "jsonrpc": "2.0",
      "method": "exchange_getBlocksInfo",
      "params": [
       108,                  // Starting block number
       109                   // End block number
    ]
  }

  - response

  ```javascript
  {
      "id": 0,
      "result": {
      [
        {
          BlockHash: "0x42fee36......d82bd53",                  // Block Hash
          Ins: ["0xd85......e0d597"],                      // UTXO root spent by this block
          BlockNumber: 108,                                        // Block height
          Outs: [{
              Currency: "SERO",
              Nil: "0xe1d29......d15d89",
              Num: 108,
              Pkr: "0x842e......950d",
              Root: "0x192717......646d42a",
              TxHash: "0xf8f2269......66d181",
              Value: 70000000000000000000
            },
            ......
          ]
        }
      ]
    }
      "error": null
  }
  ```

- **console**

```javascript
>  exchange.getBlocksInfo(108,109)
  {
    [
      {
        BlockHash: "0x42fee36......d82bd53",
        Ins: ["0xd85......e0d597"],
        BlockNum: 108,
        Outs: [{
            Currency: "SERO",
            Nil: "0xe1d29......d15d89",
            Num: 108,
            Pkr: "0x842e......950d",
            Root: "0x192717......646d42a",
            TxHash: "0xf8f2269......66d181",
            Value: 70000000000000000000
          },
          ......
        ]
      }
    ]
  }
```

### GetPkr

* Create a PKr corresponding to PK with a random number

* **jsonrpc**

  * request

  ```javascript
  {
    "id": 0,
    "jsonrpc": "2.0",
    "method": "exchange_getPkr",
    "params": [
      "0x0dbd9c096......32a20849304201ea6",    // PK hex encoding
      "0x000000000......00000000000000101"     //32 BYTE random number, need> 0x100
    ]
  }
  ```

  * response

  ```javascript
  {
    "id": 0,
    "result": "0x8423cdaf21db11......d1c76e728630a882a14",    //PKr
    "error": null
  }
  ```

* **console**

```javascript
>  exchange.getPkr(sero.accounts[0],"0x000000000......00000000000000100")
"0x4546ffe8932.......88efeead5d7a84"
```

### GetPkByPkr

- Get PKr's corresponding PK in gero

- **jsonrpc**

  - request

  ```javascript
  {
    "id": 0,
    "jsonrpc": "2.0",
    "method": "exchange_getPkByPkr",
    "params": [
      "0xa01b191......ad09bf320"    // Hex code for receipt code Pkr
    ]
  }
  ```

  - response

  ```javascript
  {
    "id": 0,
    "result": "0xc3863f5......bce8168a87",    // Public key PK
    "error": null
  }
  ```

- **console**

```javascript
>  exchange.getPkByPkr("0xa01b191......ad09bf320")
"0xc3863f5......bce8168a87"
```

### GetBalances

* Get the current total balance of the account represented by PK

* **jsonrpc**

  * request

  ```javascript
  {
    "id": 0,
    "jsonrpc": "2.0",
    "method": "exchange_getBalances",
    "params": [
      "0x0dbd9c096ca52fa44570......58332a20849304201ea6"       // Public key PK
    ]
  }
  ```

  * response 

  ```javascript
  {
      "id": 0,
      "result": {
        "tkn" : {
        "SERO": 4000000000000000000  // Currency name: balance
        },
    "tkt" : {}
    },
    "error": null
  }
  ```

* **console**

```javascript
> exchange.getBalances(web3.addressToHex(sero.accounts[0]))
{
  SERO: 169900000000000000000
}
```

### GetRecords

- Get recharge history

- **jsonrpc**

  - request

  ```javascript
  {
      "id": 0,
      "jsonrpc": "2.0",
      "method": "exchange_getRecords",
      "params": [
        1,                                    // Starting block number
        1000，                                // End block number
      "0x0dbd9c096......849304201ea6",      // Payment Code (PKr) | Account Public Key (PK) | Leave blank
      ]
  }
  ```

  - response

  ```javascript
  {
    "id": 0,
    "result": [                                                 // Top-up UTXO list
      {
        "Pkr": "0x67dc2f42a063477a7ef......1fbbfd8707b0cd449994",
        "Root": "0x13ca7a02c8......8e85b08775a3706b0",              // UTXO unique identification
        "TxHash": "0x000000000000000......00000000000000000000",    // The hash of Tx where UTXO is located
        "Nil": "0x902953f4eaec70e......b09beb8fff798a0d59ec23",     // UTXO obsolete code
        "Num": 1,                                                   // UTXO block height
    "Currency": "SERO",                                         // Currency name
        "Value": "1000000000000000000"                                // Number of coins
     }, 
     {
        "Pkr": "0x291560a9ad4db22df......7bef504d7c7544dbddabcce6e79f0b",
        "Root": "0xa9623b4c88f53e......09522c831bf508834be8a7",
        "TxHash": "0x0dd3a111270......7da11af453498",
        "Nil": "0xa6acfbc53cf68c433......0a1c0b974ad55977048069f",
        "Num": 2,
        "Currency": "SERO",                                         // Currency name
        "Value": "1000000000000000000"                                // Number of coins
     },
    ......
    ],
    "error": null
  }
  ```


- **console**

```javascript
> exchange.getRecords(1,3,sero.accounts[0])
[
  {
    Currency: "SERO",
    Nil: "0x5b3d....b0b328",
    Num: 1,
    Pkr: "0x5e3f88....1ee14",
    Root: "0xd79e00....250bc96",
    TxHash: "0x000000000......00000000000",
    Value: "17600000000000000000"
  },
  ......
]
```

### GenTx

* Offline signature version of transaction generation
* SERO has a limit on the number of inputs and outputs of a transaction
  * No more than 10 in plain text and no more than 500 in secret text
  * No more than 2500 input in plain text, no limitation in secret text input
    * GetMaxAvailable You can get the maximum amount that can be sent through the API
  * Every time GenTx is called, UTXO is rotated and the UTXO is written down.
    * GetLockedBalances Can query the amount of money that has been locked

- **jsonrpc**

  - request

  ```javascript
  {
      "id": 0,
      "jsonrpc": "2.0",
      "method": "exchange_genTx",
      "params": [{
              "From": "0x0dbd9c0......9304201ea6",                // Account's PK
      "RefundTo": "0x8423cdaf......630a882a14",          // Optional, change receipt code (PKr), if it is empty, it will be generated automatically。
        "Gas": 25000,                                       // Maximum gas consumption, minimum 25000
        "GasPrice": 1000000000,                             // GasPrice, default 1Gta
      "Cmds": {                                           // Optional, execute command parameters (>=v1.0.0-rc6)
        "BuyShare": {                                         // Purchase of shares (with From as the capital account)
          "Value": "2000000000000000000",                        // Purchase amount in Ta
          "Vote":  "0x8423cdaf......630a882a14",                 // SOLO voting address
          "Pool": "0x8414cdd......9df62dbda25b"                  // Optional, StakingNode ID
        },
        "Contract": {                                         // Calling a smart contract
          "Currency": "SERO",                                    // Currency of incoming assets
          "Value": "1000000000",                                 // Amount of incoming assets, unit Ta
          "To": "0x59bd488f......4e16a2e2b0",                    // Contract address. If it is empty, create a smart contract.
          "Data": "0x233892....228efad"                          // Data for smart contracts
        }
      },
      "Receptions": [{                                    // Recipient Information
          "Addr": "0x8423cdaf......630a882a14",             // Acceptor PKr | PK, PK will be automatically converted to PKr
          "Currency": "SERO",                               // Currency name
          "Value": 900000000000000000                       // Number of coins
      }],
      "Roots": []                                         // Which UTXOs need to be used, null values ​​represent automatic selection
    }]
  }
  ```

  - response 
  * The structure returned by this method is relatively complicated, and the result can be directly passed to the offline client for signature.

  ```javascript
  {
      "id": 0,
      "result": {
      "Gas": 25000,
      "GasPrice": 1000000000,
      "From": {
          "SKr": "0x00000000......00000000000",
          "PKr": "0xb28e17a7......ad09bf320"
      },
      "Ins": [{
          "SKr": "0x00000000......00000000000",
          "Out": {
              "Root": "0x13ca7a0......75a3706b0",
              "State": {
                  "OS": {
                      "Index": 1,
                      "Out_O": {
                          "Addr": "0x67dc2f42a063......b0cd449994",
                          "Asset": {
                              "Tkn": {
                                  "Currency": "0x0000000......0000005345524f",
                                  "Value": 1000000000000000000
                              },
                              "Tkt": null
                          },
                          "Memo": "0x00000000......0000000000"
                      },
                      "Out_Z": null,
                      "OutCM": "0xedfe90dbc76......c7e2454371e22",
                      "RootCM": "0xe07a24781......1d037f9412c23"
                  },
                  "TxHash": "0x0000000000......000000000000",
                  "Num": 1
              }
          },
          "Witness": {
              "Pos": "0x1",
              "Paths": ["0xea8a7fa27d4c......565c0ca6bf7a8", 
                  "0x2e6831a00874......35c4d21d5cd07", 
                  "0x7812d8320911.......1435b58078af", 
                  "0x47f3115ed518.......29feed9d623"
                  ......
              ],
              "Anchor": "0xa9623b4c88......508834be8a7"
          }
      }],
      "Outs": [{
          "PKr": "0x8423cdaf21d......630a882a14",
          "Asset": {
              "Tkn": {
                  "Currency": "0x000......005345524f",
                  "Value": 900000000000000000
              },
              "Tkt": null
          },
          "Memo": "0x000000......0000000"
      }, {
          "PKr": "0xb28e17a7d1d......4b740ad09bf320",
          "Asset": {
              "Tkn": {
                  "Currency": "0x000000......0005345524f",
                  "Value": 99975000000000000
              },
              "Tkt": null
          },
          "Memo": "0x00000000......000000000"
      }]
    },
    "error": null
  }
  ```


- **console**

```javascript
var txParam = exchange.genTx({
    "From":  web3.addressToHex(sero.accounts[0]),
    "Gas": 25000,
    "GasPrice": 1000000000,
    "Receptions": [{
        "Addr": web3.addressToHex(sero.genPKr(sero.accounts[1])),
        "Currency": "SERO",
        "Value": web3.toTa(1)
    }],
    "Roots": []
})
// txParam returns the same result as jsonrpc
```

### GenMergeTx

- Offline signed version of UTXO merge

- **jsonrpc**

  - request

  ```
  {
      "id": 0,
      "jsonrpc": "2.0",
      "method": "exchange_genMergeTx",
      "params": [{
          "From": "0x0dbd9c0......9304201ea6",                // Account's PK
          "To": "0x8423cdaf......630a882a14",                 // Merge to receipt code (PKr), it will be generated automatically if it is empty。
          "Currency": "SERO",                                // The name of the currency to be merged
          "Zcount": 100,                                     // Maximum number of secret text UTXO merged
         "Left": 1                                          // How many UTXOs are left
      }]
  }
  ```

  - response

    same as `genTx`

- **console**

```javascript
var txParam = exchange.genMergeTx({
    "From":  web3.addressToHex(sero.accounts[0]),
    "To": "0x8423cdaf......630a882a14",
  "Currency": "SERO", 
  "Zcount": 100, 
  "Left": 1 
})
// txParam returns the same result as jsonrpc
```

### GetTx

- Get transaction details

- **jsonrpc**

  - request

  ```javascript
  {
      "id": 0,
      "jsonrpc": "2.0",
      "method": "exchange_getTx",
      "params": [
        "0xf8f2269......66d181"           // Transaction Hash
      ]
  }
  ```

  - response

    ```javascript
    {
        "id": 0,
        "result": {
          BlockHash: "0x42fee3......d82bd53",         // Block Hash
          BlockNumber: 108,                           // Block number
          Outs: [
            {                                    // Out list
              Currency: "SERO",                           //Currency name
              PK: "0x40aa8......f4d08a96",                // Account public key
              Pkr: "0x924f6b6c......09bf320",             // Receipt code
              Root: "0x0d57fa92.....879d811",             //Root
              Value: 4999925000000000000                  //Amount
            },
            ......
          ],
          Ins: [                               // Root list of transaction input UTXO
            "0x0dbd9c0......9304201ea6"
          ],
          TxHash: "0xf8f2269......66d181"      // Transaction hash
          Fee: 25000000000000,                 //gas fee
          Timestamp: 1561442217                // Timestamp of transaction
        },
        "error": null
    }
    ```

- **console**

```javascript
> exchange.getTx("0xf8f2269......66d181")
{
    BlockHash: "0x42fee3......d82bd53",
    BlockNumber: 108,
    Outs: [
      {
        Currency: "SERO",
        PK: "0x40aa8......f4d08a96",
        Pkr: "0x924f6b6c......09bf320",
        Value: 4999925000000000000
      },
      ......
   ],
   TxHash: "0xf8f2269......66d181"
}
```

### GenTxWithSign

- Online version of transaction generation

- **jsonrpc**

  - request

  ```javascript
  {
      "id": 0,
      "jsonrpc": "2.0",
      "method": "exchange_genTxWithSign",
      "params": [{
        "From": "0x0dbd9c0......9304201ea6",                // Account's PK
        "RefundTo": "0x8423cdaf......630a882a14",          // Change receipt code (PKr), if it is empty, it will be generated automatically.
        "Gas": 25000,                                       // Maximum gas consumption, minimum 25000
        "GasPrice": 1000000000,                            // GasPrice, default 1Gta
        "Receptions": [{                                   // Recipient Information
            "Addr": "0x8423cdaf......630a882a14",          // Recipient PKr            "Currency": "SERO",                               // Currency name
            "Value": 900000000000000000                       // Number of coins
        }],
        "Roots": []                                         // Which UTXOs need to be used, null values ​​represent automatic selection。
      }]
  }

  - response
  The signed data can be directly submitted to CommitTx and sent to the entire network. At the same time, the offline signature results after GenTx are consistent with the result of GenTxWithSign.

  ```javascript
  {
      "id": 0,
      "result": {
      "Gas": "0x61a8",
      "GasPrice": "0x3b9aca00",
      "Tx": {
          "Ehash": "0x59bd488......16a2e2b0",
          "From": "0xb28e17a7......d09bf320",
          "Fee": {
              "Currency": "0x00000000000......05345524f",
              "Value": 25000000000000
          },
          "Sign": "0x7937304f......8fe12d803",
          "Bcr": "0x576cc80af......fc35a82",
          "Bsign": "0xea0c7a......2aadcb801",
          "Desc_Z": {
              "Ins": null,
              "Outs": [{
                  "AssetCM": "0x23b24db7363......af614d40861f28",
                  "OutCM": "0x16653600938......cde422f18ac00",
                  "RPK": "0xc5740db4......4efa5411d9",
                  "EInfo": "0x1f0d1dc5f......df00209c22",
                  "PKr": "0x8423cda.......630a882a14",
                  "Proof": "0x030d19322......c16ba7104"
              }, {
                  "AssetCM": "0x73280eb9......9d6d5f042c",
                  "OutCM": "0x92cace7c......1a5a528c",
                  "RPK": "0x8126a4......06607d0ee",
                  "EInfo": "0x5fa2c37......5101d8f3",
                  "PKr": "0xb28e1......09bf320",
                  "Proof": "0x026a8c617......829600c"
              }]
          },
          "Desc_O": {
              "Ins": [{
                  "Root": "0x13ca7a0......75a3706b0",
                  "Nil": "0xc179f8......9acf98d",
                  "Sign": "0xa4ef43839......eb19b6a3701"
              }],
              "Outs": null
          },
          "Desc_Pkg": {
              "Create": null,
              "Transfer": null,
              "Close": null
          }
      },
      "Hash": "0x0dd3a1112......11af453498",      //Transaction Hash
      "Roots": ["0x13ca7a0......75a3706b0"]       // Root list of input UTXO v1.0.0-rc7
    },
    "error": null
  }
  ```

- **console**

```javascript
> personal.unlockAccount(sero.accounts[0],"123456")
true
> var tx = exchange.genTxWithSign({
    "From":  web3.addressToHex(sero.accounts[0]),
    "Gas": 25000,
    "GasPrice": 1000000000,
    "Receptions": [{
        "Addr": "0x4546ffe893......eead5d7a84",
        "Currency": "SERO",
        "Value": web3.toTa(1)
    }],
    "Roots": []
})

// tx is the same as the result returned by jsonrpc
```

### CommitTx

- Submit the signed transaction to the transaction pool
- **jsonrpc**

- request 
    - GenTxWithSign Consistent with the output

- response
    - No error indicates that it has been placed in the transaction pool and is waiting for `gero` to be synchronized to the entire network.

- **console**

```javascript
> exchange.commitTx(tx)   // tx is the result of `GenTxWithSign` or offline signing
null
> sero.getTransactionReceipt(tx.Hash)
{
  blockHash: "0x780cb2866......d27218ff8e",
  blockNumber: 107,
  contractAddress: null,
  cumulativeGasUsed: 25000,
  from: "24WSzZB......gkeQJtGP",
  gasUsed: 25000,
  logs: [],
  logsBloom: "0x00000000......000000000",
  root: "0x06414dcf......78ea7c4218",
  status: "0x1",
  to: null,
  transactionHash: "0x1bae9132......7ecd7172d36",
  transactionIndex: 0
}
```

### GetPkSynced

- Exchange current analysis progress

- **jsonrpc**

  - request

  ```javascript
  {
      "id": 0,
      "jsonrpc": "2.0",
      "method": "exchange_getPkSynced",
      "params": [
          "0x0dbd9c0......9304201ea6",                //账户的PK
      ]
  }
  ```

  - response

  ```javascript
  {
      "id": 0,
        "result": {
        'currentBlock': 121,                  // Current block height
        'currentPKBlock': 121,                // block height analyzed by exchange
        'highestBlock': 121                   // Current block height across the network
        'utxoCount': {
          'SERO':100                          // SERO current number of UTXO, need to call getBalances first
        }
      },
    "error": null
  }
  ```

- **console**

```javascript
> exchange.getPkSynced("0x0dbd9c0....9304201ea6")
{
  currentBlock: 121,
  currentPKBlock: 121,
  highestBlock: 121
}
```

### Merge

- Online signature version of UTXO merged

- **jsonrpc**

  - request

  ```javascript
  {
    "id": 0,
    "jsonrpc": "2.0",
    "method": "exchange_merge",
    "params": [
        "0x0dbd9c0......9304201ea6",                // Account's PK
        "SERO"                                      // Currency of Merge
    ]
  }
  ```

  - response

  ```javascript
  {
    "id": 0,
    "result": {
      "0x1bae9132......7ecd7172d36"              // Transaction Hash generated by Merge
    },
    "error": null
  }
  ```

- **console**

```javascript
> exchange.merge("0x0dbd9c0......9304201ea6","SERO")
"0x1bae9132......7ecd7172d36"
```

### ValidAddress

- Determine whether PK or PKr is effective

- **jsonrpc**

  - request

  ```javascript
  {
      "id": 0,
      "jsonrpc": "2.0",
      "method": "exchange_validAddress",
      "params": [
        "0x0dbd9c0......9304201ea6"                 // Account's PK or PKr
      ]
  }
  ```

  - response
  
  ```javascript
  {
    "id": 0,
    "result": {
    true                                        // it is effective
    },
    "error": null
  }
  ```

- **console**

```javascript
> exchange.validAddress("0x0dbd9c0......9304201ea6")
true
```

### GetLockedBalances

- Get locked amount

- **jsonrpc**

  - request

  ```javascript
  {
      "id": 0,
      "jsonrpc": "2.0",
      "method": "exchange_getLockedBalances",
      "params": [
        "0x0dbd9c0......9304201ea6"                 // Account's PK
      ]
  }
  ```

  - response

  ```javascript
  {
    "id": 0,
    "result": {
    "SERO":7000                                // Amount that could be locked
    },
    "error": null
  }
  ```

- **console**

```javascript
> exchange.getLockedBalances("0x0dbd9c0......9304201ea6")
{
  "SERO":7000
}
```

### GetMaxAvailable

- Get the maximum amount that can currently be transferred

- **jsonrpc**

  - request

  ```javascript
  {
    "id": 0,
    "jsonrpc": "2.0",
    "method": "exchange_getMaxAvailable",
    "params": [
      "0x0dbd9c0......9304201ea6",                 // Account's PK
      "SERO"                                       // Currency name
    ]
  }

  - response

  ```javascript
  {
    "id": 0,
    "result": 700000,                             // Maximum one-time transfer amount
    "error": null
  }
  ```

- **console**

```javascript
> exchange.getMaxAvailable("0x0dbd9c0......9304201ea6", "SERO")
700000
```

### ClearUsedFlag

- Clear lock flag based on pk

- **jsonrpc**

  - request

  ```javascript
  {
    "id": 0,
    "jsonrpc": "2.0",
    "method": "exchange_clearUsedFlag",
    "params": [
      "0x0dbd9c0......9304201ea6"                          // Account's PK
    ]
  }

  - response

  ```javascript
  {
    "id": 0,
    "result": 3,                       // Cleared 3 UTXO marks
    "error": null
  }
  ```

- **console**

```javascript
> exchange.clearUsedFlag("0x0dbd9c0......9304201ea6")
3
```

### ClearUsedFlagForRoot

* Clear lock mark based on UTXO's Root

- **jsonrpc**

  - request

  ```javascript
  {
    "id": 0,
    "jsonrpc": "2.0",
    "method": "exchange_clearUsedFlagForRoot",
    "params": [
      [
        "0x13ca7a0......75a3706b0",                 //UTXO Root
        "0x244ae92......976fa00bc"
      ]
    ]
  }
  ```

  - response

  ```javascript
  {
    "id": 0,
    "result": 2,
    "error": null
  }
  ```

- **console**

```javascript
> exchange.clearUsedFlagForRoot(["0x0dbd9c0......9304201ea6"])
null
```

## Suggested Listing Solution

### Account management

* Account generation
  * Generated via offline client
    * Randomly generate a 32bytes seed and save it securely
    * Call the account object of `js-sero-client` to generate `TK` and `PK`
      * It is recommended to use the more secure SuperZK2.0 protocol to create accounts
* Generated by `gero`
  * Generate a new account by calling `personal.newAccount` in the `gero` console
  * Export the `seed` through `personal.exportRawKey` for safe keeping
    * You can also save the corresponding `keystore` file
  * Get account `TK` through `sero.getTk`
  * Get account `PK` via `sero.accounts`
* Account import
  * Import personal `TK` by calling `personal.importTk` through `gero` console
  * Monitor the analysis of the `exchange` service through logs

### Recharge monitoring

* Call `exchange.GetRecords` to continuously synchronize new recharge records of the `PK` according to the block number.
  * **Note: SERO is a private public chain. When signing a transaction, the referenced `UTXO` needs to be proved. If there are more `UTXOs` referenced in the transaction, the transaction signature time will be very long. Therefore, it is necessary to merge the recharged `UTXO` daily, so that the user will have a good experience when withdrawing cash.
  * SERO provides a method for generating offline and non-offline signature merge `UTXO` transactions.
    * Off-line signing [`GenMergeTx`](#GenMergeTx)
    * On-line signature [`Merge`](#Merge)

### Withdrawal

* Configure a `preTxParam` object (refer to the input of `GenTx`)
* Offline signature method
  * Call `GenTx` to get the `txParam` object.
  * Call the `txsign` method signature of `js-sero-client`
  * Get signature results `tx`
* Online signature method
  * Unlock the `account` of `gero`
  * Call `GenTxWithSign` to generate signed transaction `tx`
* Save the hash value of `tx`
* Call `CommitTx` to submit `tx` to the full node
* Call `sero.getTransactionReceipt` to scan the completion of the transaction
* Since `UTXO` cannot be reused, and `genTx` will lock the `UTXO` used this time, it is recommended when generating transactions
  * Get the maximum amount that can be sent this time through `exchange.getMaxAvailable`
    * You need to merge `UTXO` to ensure that the current amount can be sent
  * The value obtained by `exchange.getMaxAvailable` will change each time a transaction is generated, representing the amount that can be sent next time. 
    * Call `exchange.getMaxAvailable` and `exchange.genTx | genTxWithSign` in a loop until `exchange.getMaxAvailable` is 0
    * Wait for new `UTXO` to be generated after sending the transaction
  * If any transaction fails, in addition to repeatedly submitting the transaction, you can clear the lock on these `UTXO` through `exchange.ClearUsedFlag`

### Automatic UTXO Merger

* If it is online signature, you can use
  * `exchange’s` automatic merge function.
    * Add `--autoMerge` parameter when starting `gero`
    * When the account under `pk` is scheduled, automatic UTXO merger will be performed regularly
  * Call the `exchange.Merge` method in the console to merge manually

* The offline signing direction can use `exchange.genMergeTx` to configure a merge transaction
  * The transaction is then sent after being signed offline


